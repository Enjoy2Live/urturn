[{"title":"Semantle Battle Tournament (11/5/2022)","type":0,"sectionRef":"#","url":"/blog/Semantle Battle Tournament","content":"","keywords":""},{"title":"What‚Äã","type":1,"pageTitle":"Semantle Battle Tournament (11/5/2022)","url":"/blog/Semantle Battle Tournament#what","content":"Semantle Battle is a spin off of the original semantle game where two players pick secrets for one another to guess. The player who guesses the secret first wins.Play it with a friend here to prepare before the tournament. "},{"title":"When‚Äã","type":1,"pageTitle":"Semantle Battle Tournament (11/5/2022)","url":"/blog/Semantle Battle Tournament#when","content":"Tournament will be hosted Saturday 11/5/2022 2:00 PM PST.RSVP in the Discord as soon as possible, we will cap the number of participants. "},{"title":"Where‚Äã","type":1,"pageTitle":"Semantle Battle Tournament (11/5/2022)","url":"/blog/Semantle Battle Tournament#where","content":"Always Discord. "},{"title":"How‚Äã","type":1,"pageTitle":"Semantle Battle Tournament (11/5/2022)","url":"/blog/Semantle Battle Tournament#how","content":"Entry is Free. Tournament Structure‚Äã We will auto generate a random bracket with every player that RSVPs in the Discord.All games will be screen shared (each player will share their screen in two separate channels) to ensure no cheating.Each player starts out on their own and are their own team leader (i.e. each team will have 1 player at the first round).When a team wins, the two teams combine and the new team leader is the team leader of the winning team. Eventually the last Semantle Battle will be between two large teams.Only the team leader can type in guesses. Teams will not have access to the other teams voice chat/text channel. Prizes‚Äã Team leader of last team standing gets the only ultimate tournament winner discord role.Players on the winning team will get a tournament winner discord role. Rules‚Äã No Cheating of any form (you will be disqualified immediately, banned from the discord server, and the UrTurn platform - seriously don't ruin the fun of others).The winner is chosen based on the player in this order of priority: player who guessed the word firstclosest word index-wise (e.g. 99th word in nearest list is better than 70th word in nearest list)closest word similarity score-wise Each game you have 30 seconds to provide your secret and 5 minutes to guess the other player's secret. At the end of the 5 minutes, a winner is chosen. "},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/welcome","content":"Get the latest on new features, awesome games, upcoming events, and technology from the UrTurn team.","keywords":""},{"title":"Advanced Guides","type":0,"sectionRef":"#","url":"/docs/Advanced","content":"Advanced Guides This section is not going to be very structured but will cover several specific use cases: üìÑÔ∏è Custom Game Page Fully customize your game page üìÑÔ∏è Self Hosting UrTurn Instructions to self host all of UrTurn in case we get kidnapped by Roblox, sent to antarctica, and forced build Roblox games.","keywords":""},{"title":"Custom Game Page","type":0,"sectionRef":"#","url":"/docs/Advanced/custom-game-page","content":"Custom Game Page Customize the game page posting on UrTurn. The default look is often not enough to fully sell your game to players. caution This work is in progress. Join the early release wait list on discord. Ideally, you will be able to modify and use any game data on the front page for a much more unique and richer experience for your players.","keywords":""},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs","content":"","keywords":""},{"title":"What UrTurn Is‚Äã","type":1,"pageTitle":"Introduction","url":"/docs#what-urturn-is","content":"UrTurn is a game platform that hosts and handles all infrastructure for your game: networking, multiplayer, matchmaking, and data storage. The framework lets you modify game state of a room in a transactional and event-based manner. Just define how to modify game states on each event, and that's it (no infrastructure headaches, no worrying about scale again).  "},{"title":"Perfect for‚Äã","type":1,"pageTitle":"Introduction","url":"/docs#perfect-for","content":"Turn based games (e.g. any board game)Word games with several updates per secondGames that can be represented as state machinesMonetizing Single Player Games (coming soon) "},{"title":"Opinionated Where It Matters‚Äã","type":1,"pageTitle":"Introduction","url":"/docs#opinionated-where-it-matters","content":"We are obsessed with a great developer experience. This means we abstract away complicated infrastructure in scalable and best practice way that just makes sense. "},{"title":"What UrTurn is NOT‚Äã","type":1,"pageTitle":"Introduction","url":"/docs#what-urturn-is-not","content":"info UrTurn is NOT opinionated on the frontend of your game or your dev environment. Continue to use your favorite frontend web technologies (e.g. vanilla HTML5, ReactJS, PhaserIO, BabylonJS, etc.), and hook into UrTurn using the @urturn/client.Continue to use your favorite IDE for coding with JavaScript, and continue using your favorite dev tools and open source libraries. info UrTurn's framework is NOT closed source. We want developers to have as much control over the look and feel of their game, and post them anywhere, host them anywhere.If you wanted to self host UrTurn, you can because all code is available on GitHub. See self-hosting guide. caution UrTurn is NOT a real time gaming framework Despite this limitation, there is a set of rich potential use cases for it that can make exciting and fun games. See the front page.Join the early release wait list on discord, so we can notify you when we add support. caution UrTurn is NOT fully stable yet. It is in Alpha. This means that there may be some breaking changes. We will try to avoid them as much as possible, and will always notify developers in our discord. "},{"title":"Self Hosting UrTurn","type":0,"sectionRef":"#","url":"/docs/Advanced/self-hosting","content":"","keywords":""},{"title":"Self hosting instructions‚Äã","type":1,"pageTitle":"Self Hosting UrTurn","url":"/docs/Advanced/self-hosting#self-hosting-instructions","content":"caution This work is planned. Join discord to provide more details on your use case. We guarantee instructions are posted in the case we become insolvent. "},{"title":"@UrTurn/client","type":0,"sectionRef":"#","url":"/docs/API/client","content":"","keywords":""},{"title":"Fields‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#fields","content":""},{"title":"client.events EventEmitter‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#clientevents-eventemitter","content":"client.events.on('onStateChanged', (newRoomState: RoomState) =&gt; {})‚Äã Calls the callback anytime the current RoomState changes for the room "},{"title":"Methods‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#methods","content":""},{"title":"client.makeMove(move: Move)‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#clientmakemovemove-move","content":"Move is any JSON serializable objectreturns Promise&lt;MoveResult&gt; if the move is accepted "},{"title":"client.getLocalPlayer()‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#clientgetlocalplayer","content":"returns the local player object info You can tell if the local player is a spectator or a regular player if they are not in the players list. This will help you display a different view if the game is in spectator mode. "},{"title":"client.getRoomState()‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#clientgetroomstate","content":"returns the current RoomState "},{"title":"Types‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#types","content":""},{"title":"MoveResult‚Äã","type":1,"pageTitle":"@UrTurn/client","url":"/docs/API/client#moveresult","content":"error Error object if an error occurredundefined if no error ocurred success true if successful (no error ocurred)undefined if an error occurred Example: // successful move { &quot;success&quot;: true } // error occurred { &quot;error&quot;: { &quot;name&quot;: &quot;invalid move&quot;, &quot;message&quot;: &quot;player billy made an invalid move, it wasn't their turn } }  "},{"title":"Room Functions","type":0,"sectionRef":"#","url":"/docs/API/room-functions","content":"","keywords":""},{"title":"Flow‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#flow","content":"All functions follow this flow when handling an event: "},{"title":"Pure Functions‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#pure-functions","content":"All room functions are pure: return values are identical for identical arguments.has no side effects within the function itself. caution Avoid modifying any variables scoped outside of the function, as there is no guarantee those modifications will last within the same room and may affect other rooms. Using global constants is fine, or loading in constants from an external file. caution Common mistake is to forget returning the roomStateResult. Make sure you are returning any resulting state, otherwise the changes will not be applied! "},{"title":"ACID Transactions‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#acid-transactions","content":"All room functions are ACID transactions: Atomic: either all updates returned are fully completed or completely fail. This is important for handling functions like player purchases; you don‚Äôt want a player to be charged Urbux and fail to give them their desired item. This prevents data corruption of your roomState.Consistent: your functions will never be given partial data or corrupt data; they will always get the latest roomState for the room.Isolated: you are guaranteed that functions for a given room are handled one by one. No two functions can corrupt each other.Durable: successful room functions are guaranteed to survive system failure. Even if UrTurn goes down, or has partial outages, your data for each room should survive. "},{"title":"onRoomStart Required‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#onroomstart-required","content":"onRoomStart = (roomState: RoomState) =&gt; RoomStateResult  Use this function to initialize your board game state.Runs when the room is first initialized, as triggered by these actions: When a private room is created (player clicks Create Private Room).When a room is created for the matchmaking queue (player clicks Play). Fails on error (when user clicks play or attempts start a game, it will show them an error and will not start the game).Returns the RoomStateResult. "},{"title":"onPlayerJoin Required‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#onplayerjoin-required","content":"onPlayerJoin = (player: Player, roomState: RoomState) =&gt; RoomStateResult  Runs when a player joins the room, including when the room is created (i.e. the player clicks Play or Create Private Room).Fails on error (when user clicks play and joins a game, it will show them an error snackbar).If roomState.joinable or roomState.finished is true then it is guaranteed that no player will be added to the room and onPlayerJoin will never be called for a player.Returns the RoomStateResult. "},{"title":"onPlayerQuit Required‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#onplayerquit-required","content":"onPlayerQuit = (player: Player, roomState: RoomState) =&gt; RoomStateResult  Runs when a player quits the game.A player can quit the game by manually clicking the quit button.Only players in the room, can quit the room (e.g. we can't call onPlayerQuit with a player not known to the room).Returns the RoomStateResult. caution onPlayerQuit is forced. Even if an error occurs in your code, we will force our own logic to be executed (e.g. removing player from the roomState.players list). This may put the roomState for the room in a corrupt state depending on your code, so you should avoid erroring in this function. "},{"title":"onPlayerMove Required‚Äã","type":1,"pageTitle":"Room Functions","url":"/docs/API/room-functions#onplayermove-required","content":"onPlayerMove = (player: Player, move: Move, roomState: RoomState) =&gt; RoomStateResult  Runs when a player moves (i.e. when client.makeMove() is called with the move JSON object).Fails on error. The client triggering this will receive your error as a return value.Returns the RoomStateResult. info If a player is trying to do something impossible/against game rules, then it is recommended to throw an error, so you can handle it in the game frontend. "},{"title":"@UrTurn/runner","type":0,"sectionRef":"#","url":"/docs/API/runner","content":"","keywords":""},{"title":"Commands‚Äã","type":1,"pageTitle":"@UrTurn/runner","url":"/docs/API/runner#commands","content":"$ npx runner -h Usage: runner [options] Options: --no-clear Don't clear console when starting the runner. -f, --frontend-port &lt;frontendPort&gt; Specify the port of where the frontend of your game is being hosted locally. -d, --debug print debug logs to stdout -h, --help display help for command  caution NOT all commands are printed above. You should run runner -h locally to know what is available. It is possible you have a different version. "},{"title":"Types","type":0,"sectionRef":"#","url":"/docs/API/types","content":"","keywords":""},{"title":"RoomState‚Äã","type":1,"pageTitle":"Types","url":"/docs/API/types#roomstate","content":"RoomState object is provided to each room function, and will have the fields: roomState.joinable: bool default: trueIf true, new users will be able to join this game instance.If false, new users can not join this game instance via a private room or matchmaking. roomState.finished: bool default: false.If true, no new functions will be called for the room (e.g. no new players can join, players can't make moves anymore, etc.). Marking a room finished is important for UrTurn to index each room properly.If false, the game will show in the &quot;Active Games&quot; list for players. roomState.state: JSON object default: {}Can hold any valid JSON object, and is designed for you to put any data you want to make your game logic possible.If you try to store non JSON serializable values like functions, they will be parsed out.Max size is 15mb. roomState.players: Player[], read-only default: []UrTurn manages this field and will add a player object to the list before calling onPlayerJoin and removes the player object from the list before calling onPlayerQuit.Sorted in the order players joined the room (earliest player first with later players further in the array). roomState.version: int, read-only default: 0UrTurn manages this field and increments the version by 1 every time a function successfully modifies it. roomState.roomStartContext: RoomStartContext, read-only default: {}Provides crucial information on context of how this room was createdFor example, private rooms will set roomState.roomStartContext.private = true. roomState.logger: RoomLogger, read-only, room functions only Logger object used to log out metadata or message.This helps us correlate logs in the same function call. "},{"title":"RoomStartContext‚Äã","type":1,"pageTitle":"Types","url":"/docs/API/types#roomstartcontext","content":"RoomStartContext is an object that is defined by how the player created the room. This is useful whenever you want your game to behave differently depending on how the room started. RoomStartContext.private bool true if the room is private (other players will not be able to access the room without the link)false if the room is public. This means players can queue up and join this room. // Example 1. Default (User clicks `Play`) roomState.roomStartContext = { private: false } // Example 2. Private Rooms (User clicks `Create Private Room`) roomState.roomStartContext = { private: true }  caution It is not possible to have custom RoomStartContext. We are still brainstorming on a good solution for this. Please join our discord to tell us about your use case. "},{"title":"RoomLogger‚Äã","type":1,"pageTitle":"Types","url":"/docs/API/types#roomlogger","content":"RoomLogger is an object to be used to log any metadata or message RoomLogger.info (...args) =&gt; void Logs at the info level RoomLogger.warn (...args) =&gt; void Logs at the warn level RoomLogger.error (...args) =&gt; void Logs at the error level caution Viewing production logs is not supported yet. Provide details on your use case at our discord. "},{"title":"RoomStateResult‚Äã","type":1,"pageTitle":"Types","url":"/docs/API/types#roomstateresult","content":"RoomStateResult object is returned by every exported function. All fields are optional (omitting a field will make no edits to the current value). This object can have all the non read-only fields as the RoomState. "},{"title":"Player‚Äã","type":1,"pageTitle":"Types","url":"/docs/API/types#player","content":"player.id: string Unique identification string for the player.No two players will have the same id.Player's cannot ever change their id. player.username: string Unique amongst any player at a point in time.Player may change their username. { // example &quot;id&quot;: &quot;90123018123dsf&quot;, &quot;username&quot;: &quot;billy&quot; }  "},{"title":"Move‚Äã","type":1,"pageTitle":"Types","url":"/docs/API/types#move","content":"Any JSON serializable object. Example: { &quot;y&quot;: 1, &quot;nested&quot;: {&quot;field&quot;: &quot;hello world&quot;} // ... any other field }  "},{"title":"Deploying your game","type":0,"sectionRef":"#","url":"/docs/Getting-Started/Deploying-Your-Game","content":"","keywords":""},{"title":"Manual Deployment‚Äã","type":1,"pageTitle":"Deploying your game","url":"/docs/Getting-Started/Deploying-Your-Game#manual-deployment","content":"Go to UrTurn Dev Console.Click create game or edit an existing gameFill in the required fieldsProvide the commit SHA that you want to deployClick Create or Update "},{"title":"Continuous Deployment‚Äã","type":1,"pageTitle":"Deploying your game","url":"/docs/Getting-Started/Deploying-Your-Game#continuous-deployment","content":"caution Not supported yet. Join the early release wa`it list on discord, so we can notify you when we add support. "},{"title":"Build Artifact Spec‚Äã","type":1,"pageTitle":"Deploying your game","url":"/docs/Getting-Started/Deploying-Your-Game#build-artifact-spec","content":"The commit that is deployed in production needs to have the format: game ‚îÇ index.js # rollup should transpile all of you javascript files and dependencies into this file | thumbnail.png # not required, but if not provided UrTurn will display a stock image for your game | ‚îî‚îÄ‚îÄ‚îÄfrontend/build ‚îÇ ‚îÇ # all the built html, css, javascript files go here  Here is an example for TicTacToe. tip This is easily achieved using GitHub Actions. Steps in getting started should automatically generate the correct actions for you. "},{"title":"Generating a new UrTurn Game","type":0,"sectionRef":"#","url":"/docs/Getting-Started/runner-init","content":"","keywords":""},{"title":"Create Game‚Äã","type":1,"pageTitle":"Generating a new UrTurn Game","url":"/docs/Getting-Started/runner-init#create-game","content":"npx @urturn/runner init my-game # generates new game files cd my-game npm run dev # run the game locally  caution Windows users must use WSL. We currently do not support powershell/command prompt. Make sure to keep files and folders in your WSL directories (they should NOT be under /mnt/c, use /home/&lt;user&gt;/ instead). "},{"title":"File/Folder structure‚Äã","type":1,"pageTitle":"Generating a new UrTurn Game","url":"/docs/Getting-Started/runner-init#filefolder-structure","content":"game ‚îÇ package.json # npm package specification for dependencies for your room functions (includes @urturn/runner for local development) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ.github/workflows # contains important GitHub actions that create a build artifact for UrTurn to use ‚îÇ ‚îî‚îÄ‚îÄ‚îÄsrc ‚îÇ ‚îÇ main.js # room functions (e.g. onRoomStart, onPlayerMove, etc.) ‚îÇ ‚îî‚îÄ‚îÄ‚îÄfrontend # holds all the files related to your game frontend ‚îÇ package.json # npm package specification for dependencies on your frontend (includes @urturn/client) ‚îÇ ...your frontend files  "},{"title":"GitHub Actions in .github/workflows‚Äã","type":1,"pageTitle":"Generating a new UrTurn Game","url":"/docs/Getting-Started/runner-init#github-actions-in-githubworkflows","content":"tip No GitHub Actions experience needed! We've already done the hard work for you. When you ran npx @urturn/runner init my-game, the correct github actions were created for you. When you push to main branch of your repo on GitHub, the actions will automatically create the correct Artifact structure, which you will use to deploy to production. "},{"title":"Typescript Support","type":0,"sectionRef":"#","url":"/docs/Getting-Started/typescript-support","content":"Typescript Support caution Not supported yet. Join the early release wait list on discord, so we can notify you when we add support.","keywords":""},{"title":"Concepts","type":0,"sectionRef":"#","url":"/docs/Introduction/Concepts","content":"","keywords":""},{"title":"Basic architecture‚Äã","type":1,"pageTitle":"Concepts","url":"/docs/Introduction/Concepts#basic-architecture","content":"This diagram shows 4 systems. You write code for the web frontend and the room functions. We write code for the runner and client so you don't have to.  tip All infrastructure shown is managed, scaled, and operated by UrTurn. For you, it will feel like your frontend is seamlessly communicating directly with your room functions. caution The user is able to control the game frontend.This means critical game logic should always be in your room functions (e.g. validation of user data, handling transition of state, etc.), which is managed by our cloud servers. "},{"title":"Room‚Äã","type":1,"pageTitle":"Concepts","url":"/docs/Introduction/Concepts#room","content":"Rooms are instances of games.Rooms will have an associated RoomState to track the current state of the room.Players create new rooms whenever they click play on your game. UrTurn will automatically place players together in a room if it is public.private rooms are created by players when they click create private room. You can handle private rooms differently than public rooms (see roomStartContext) in your room functions.For example, you might want players to be able to control various game settings or rules in a private room. If a user accidentally closes their browser, they may reopen it to view the room again (exception: see disconnectTimeout) "},{"title":"Game‚Äã","type":1,"pageTitle":"Concepts","url":"/docs/Introduction/Concepts#game","content":"Each game can have a thumbnail, title, description, and specific code related to it that is run whenever a room is created. "},{"title":"Automatic Disconnect Handling‚Äã","type":1,"pageTitle":"Concepts","url":"/docs/Introduction/Concepts#automatic-disconnect-handling","content":"When a user is disconnected from a public room, the user will be automatically kicked from the room with onPlayerQuit after 30 seconds.This does not apply to private rooms! Meaning, even if a player disconnects from a private room indefinitely, they will not be forced out of it. "},{"title":"Flow of a Simple Game","type":0,"sectionRef":"#","url":"/docs/Introduction/Flow-Of-Simple-Game","content":"","keywords":""},{"title":"TicTacToe‚Äã","type":1,"pageTitle":"Flow of a Simple Game","url":"/docs/Introduction/Flow-Of-Simple-Game#tictactoe","content":"Let's walk through a simple TicTacToe game that you made: "},{"title":"1. Player Billy clicks Play‚Äã","type":1,"pageTitle":"Flow of a Simple Game","url":"/docs/Introduction/Flow-Of-Simple-Game#1-player-billy-clicks-play","content":" UrTurn calls your room function implementation of onRoomStart to initialize the room state. Initial roomStateonRoomStart code { &quot;joinable&quot;: true, // defaults to true, (when set to false, UrTurn prevents any new players from joining the room) &quot;finished&quot;: false, // defaults to false, (when set to true, UrTurn prevents any new moves from being made) &quot;state&quot;: { // this field can be any JSON object that you define. This was provided in the roomStateResult by the room function above. &quot;status&quot;: &quot;preGame&quot;, &quot;board&quot;: [ [ null, null, null ], [ null, null, null ], [ null, null, null ] ], &quot;winner&quot;: null, }, &quot;version&quot;: 0, // metadata controlled by UrTurn; as each new `RoomState` gets created, this gets incremented by 1 &quot;players&quot;: [], // metadata controlled by UrTurn; when a player joins the room, they are added here to the list. When they quit the room, they are removed. }  UrTurn calls onPlayerJoin function with Billy player object and the previous roomState created earlier. roomState resultonPlayerJoin Code { &quot;joinable&quot;: true, // room should still let players join because there are not enough players to play tictactoe yet &quot;finished&quot;: false, &quot;state&quot;: { &quot;status&quot;: &quot;preGame&quot;, &quot;board&quot;: [ [ null, null, null ], [ null, null, null ], [ null, null, null ] ], &quot;winner&quot;: null }, &quot;version&quot;: 1, // incremented because our room function successfully modified the state &quot;players&quot;: [ // new player is in the player list { &quot;id&quot;: &quot;id_0&quot;, &quot;username&quot;: &quot;billy&quot; } ] }  Updates are propagated to clients by sending an event to client.events.on('stateChanged') so your game frontend can update the view for the player.  "},{"title":"2. Player Sarah clicks Play‚Äã","type":1,"pageTitle":"Flow of a Simple Game","url":"/docs/Introduction/Flow-Of-Simple-Game#2-player-sarah-clicks-play","content":"UrTurn matchmaking system puts Sarah to the same room as Billy. The same function onPlayerJoin is called with Sarah player object and the previous roomState, which produces the result (changes are highlighted): { &quot;joinable&quot;: false, // no longer joinable as we have enough players! &quot;finished&quot;: false, &quot;state&quot;: { &quot;status&quot;: &quot;inGame&quot;, // game is now in game and we can start playing! &quot;board&quot;: [ [ null, null, null ], [ null, null, null ], [ null, null, null ] ], &quot;winner&quot;: null, &quot;plrToMoveIndex&quot;: 0 }, &quot;version&quot;: 2, &quot;players&quot;: [ { &quot;id&quot;: &quot;id_0&quot;, &quot;username&quot;: &quot;billy&quot; }, { // new player &quot;sarah&quot;, added by UrTurn runner &quot;id&quot;: &quot;id_1&quot;, &quot;username&quot;: &quot;sarah&quot; } ] }  Updates are propagated to all clients: Sarah's browserBilly's browser "},{"title":"3. Billy puts X in top left corner‚Äã","type":1,"pageTitle":"Flow of a Simple Game","url":"/docs/Introduction/Flow-Of-Simple-Game#3-billy-puts-x-in-top-left-corner","content":"Billy's browserSarah's browser Your frontend calls client.makeMove({ x: 0, y: 0 }) whenever it detected billy clicking a button on the board info The client.makeMove function takes any move JSON! UrTurn calls onPlayerMove function to handle the arbitrary move: roomState resultonRoomStart code Resulting roomState (changes are highlighted): { &quot;joinable&quot;: false, &quot;finished&quot;: false, &quot;state&quot;: { &quot;status&quot;: &quot;inGame&quot;, &quot;board&quot;: [ [ &quot;X&quot;, // Billy‚Äôs move! null, null ], [ null, null, null ], [ null, null, null ] ], &quot;winner&quot;: null, &quot;plrToMoveIndex&quot;: 1 // next move is Sarah‚Äôs }, &quot;version&quot;: 3, &quot;players&quot;: [ { &quot;id&quot;: &quot;id_0&quot;, &quot;username&quot;: &quot;billy&quot; }, { &quot;id&quot;: &quot;id_1&quot;, &quot;username&quot;: &quot;sarah&quot; } ] }  "},{"title":"4. Room functions are pure functions‚Äã","type":1,"pageTitle":"Flow of a Simple Game","url":"/docs/Introduction/Flow-Of-Simple-Game#4-room-functions-are-pure-functions","content":"Notice how all of the implemented room functions (onRoomStart, onPlayerJoin, etc.) takes in the current roomState and several other arguments and returns a roomStateResult. Data should feel like a natural flow of transformations throughout time: This makes it easier to understand, debug, and test your room functions. More on pure functions. "},{"title":"Getting the hang of it?‚Äã","type":1,"pageTitle":"Flow of a Simple Game","url":"/docs/Introduction/Flow-Of-Simple-Game#getting-the-hang-of-it","content":"tip You just write code for how state changes based on various room events - player joins, quits, makes move, etc. UrTurn takes care of the rest. Try implementing the entire TicTacToe game and deploying it to production so anyone can play it! "},{"title":"Create a simple TicTacToe game","type":0,"sectionRef":"#","url":"/docs/Getting-Started/tictactoe","content":"","keywords":""},{"title":"Overview‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#overview","content":"We are ready to make our first game - tic-tac-toe! There are two major components of your game: the frontend and the room functions. We will go over the basics of each. "},{"title":"Defining the room functions‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#defining-the-room-functions","content":""},{"title":"What is roomState?‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#what-is-roomstate","content":"Your game state is held in the RoomState object. You can tell UrTurn if your game is joinable and/or if it is finished. You can also define the &quot;state&quot; object that will define the way the board currently looks. For this tic-tac-toe game, the roomState state will look like this: { &quot;players&quot;: &quot;[]&quot;, // controlled by UrTurn &quot;version&quot;: 0, // controlled by UrTurn &quot;joinable&quot;: true, &quot;finished&quot;: false, &quot;state&quot;: { &quot;board&quot;: &quot;[ [null, null, null], [null, null, null], [null, null, null], ]&quot;, &quot;winner&quot;: null } }  We will be manipulating the joinable, finished, and state properties of this object to control our game. "},{"title":"Four Functions - That's It!‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#four-functions---thats-it","content":"All of our game logic can be encompassed by the following four functions: 1. onRoomStart‚Äã This function will be called whenever a room is created. When the game starts, we want to initialize our empty roomState, which includes the following for tic-tac-toe: The Board: A 3x3 square, initialized with null values.The Winner: The winner's ID, if there is a winner. Initially null. index.js function onRoomStart() { return { state: { board: [ [null, null, null], [null, null, null], [null, null, null], ], winner: null } }; }  2. onPlayerJoin‚Äã This function will be called whenever a player actually joins the game. It provides us with the ID of the player who joined as well as the current RoomState. If this is the first player to join, we will just return an empty object. If this is the second player to join, then the game has all the necessary players and should be marked as not joinable. index.js function onPlayerJoin(plr, roomState) { const { players } = roomState; if (players.length === 2) { return { joinable: false }; } return { }; }  3. onPlayerMove‚Äã This function will be called whenever a player makes a move. It provides us with the ID of the player who made the move, the move object, and the current board game state. We can define the move object as any valid JSON object - for tic-tac-toe, it will be an object containing the x- and y-coordinates of the square they selected. After the move is completed, if we determine the game is over and there is a winner, we will add the winner's ID to our state so it can be displayed on the frontend. SnippetFull Code index.js function onPlayerMove(plr, move, roomState) { const { state, players } = roomState; const { board, plrToMoveIndex } = state; const { x, y } = move; const plrMark = getPlrMark(plr, players); board[x][y] = plrMark; const [isEnd, winner] = isEndGame(board, players); if (isEnd) { state.winner = winner; return { state, finished: true }; } return { state }; }  4. onPlayerQuit‚Äã This function will be called whenever a player quits the game. It provides us with the player who quit and the current board game state. For tic-tac-toe, the game will end if one of the players quits. The game will be marked as not joinable and finished, and the remaining player will be marked the winner. index.js function onPlayerQuit(plr, roomState) { const { state, players } = roomState; if (players.length === 1) { const [winner] = players; state.winner = winner; return { state, joinable: false, finished: true }; } return { joinable: false, finished: true }; }  "},{"title":"Frontend‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#frontend","content":"This section will go over how to implement the frontend for our tic-tac-toe so that it is visible to the user. We will be adding our components to frontend/src/App.jsx. This file already contains some logic for you to access the RoomState object and for any state changes to make to be propagated to your room functions. "},{"title":"1. Extract the RoomState‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#1-extract-the-roomstate","content":"We will first extract the information we need from the RoomState: SnippetFull Code frontend/src/App.jsx const { state: { board } = { board: [ [null, null, null], [null, null, null], [null, null, null] ] } } = roomState;  "},{"title":"2. Create a Tic-Tac-Toe Board‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#2-create-a-tic-tac-toe-board","content":"Using our defined empty board field, we can render a simple tic-tac-toe board: SnippetFull Code Live Editor function App(props) { return ( &lt;ThemeProvider theme={theme}&gt; &lt;Typography&gt; &lt;Stack margin={2} spacing={1} direction=&quot;row&quot; justifyContent=&quot;center&quot;&gt; &lt;Box&gt; {board.map((row, rowNum) =&gt; ( &lt;Stack key={rowNum} direction=&quot;row&quot;&gt; {row.map((val, colNum) =&gt; ( &lt;Stack key={colNum} direction=&quot;row&quot; justifyContent=&quot;center&quot; alignItems=&quot;center&quot; sx={{ border: 1, borderColor: 'text.primary', height: '100px', width: '100px', }} &gt; &lt;Typography color=&quot;text.primary&quot; fontSize=&quot;60px&quot;&gt; {val} &lt;/Typography&gt; &lt;/Stack&gt; ))} &lt;/Stack&gt; ))} &lt;/Box&gt; &lt;/Stack&gt; &lt;/Typography&gt; &lt;/ThemeProvider&gt; ); } function App(props) { return ( &lt;ThemeProvider theme={theme}&gt; &lt;Typography&gt; &lt;Stack margin={2} spacing={1} direction=&quot;row&quot; justifyContent=&quot;center&quot;&gt; &lt;Box&gt; {board.map((row, rowNum) =&gt; ( &lt;Stack key={rowNum} direction=&quot;row&quot;&gt; {row.map((val, colNum) =&gt; ( &lt;Stack key={colNum} direction=&quot;row&quot; justifyContent=&quot;center&quot; alignItems=&quot;center&quot; sx={{ border: 1, borderColor: 'text.primary', height: '100px', width: '100px', }} &gt; &lt;Typography color=&quot;text.primary&quot; fontSize=&quot;60px&quot;&gt; {val} &lt;/Typography&gt; &lt;/Stack&gt; ))} &lt;/Stack&gt; ))} &lt;/Box&gt; &lt;/Stack&gt; &lt;/Typography&gt; &lt;/ThemeProvider&gt; ); } Result Loading... "},{"title":"3. Add MakeMove()‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#3-add-makemove","content":"We can now add in the ability for a player to make a move. We'll add an onClick handler to each tic-tac-toe square that will send a move containing the x- and y-coordinates (the row and column numbers of the box they clicked on) to the client. UrTurn will handle sending the move to your onPlayerMove function! SnippetFull Code frontend/src/App.jsx onClick={async (event) =&gt; { event.preventDefault(); const move = { x: rowNum, y: colNum }; await client.makeMove(move); }}  "},{"title":"Adding a Thumbnail‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#adding-a-thumbnail","content":"We'll now find a suitable thumbnail for our game, such as this one. We'll download it, upload it at the highest level of our folder structure, and rename it &quot;thumbnail.png&quot; (the actual filetype doesn't matter - but it must have this name). "},{"title":"Testing Your Game‚Äã","type":1,"pageTitle":"Create a simple TicTacToe game","url":"/docs/Getting-Started/tictactoe#testing-your-game","content":"We're now ready to test our game! In the Runner, you should see the empty board game state. Click Add Player to add a player to the game. This will open a new tab that simulates what the player will see upon joining. In our game state, &quot;joinable&quot; still says true. We can add an additional player and see that &quot;joinable&quot; is now set to false, as defined in our onPlayerJoin function. You can now simulate playing tic-tac-toe between the two tabs! Here is the finished tic-tac-toe game in production, which includes error handling, move validation, player validation, and more! "}]